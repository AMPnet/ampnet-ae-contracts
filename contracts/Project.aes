contract TokenInterface =
    function allowance : (address, address) => int
    function approve : (address, int) => bool
    function transfer : (address, int) => bool
    function transferFrom : (address, address, int) => bool

contract CoopInterface =
    function token: () => TokenInterface

contract OrgInterface =
    function isVerified : () => bool
    function coop : () => CoopInterface
    function owner : () => address

contract Project =
    record state = {
        _organization               : OrgInterface,
        _minInvestmentPerUser       : int,
        _maxInvestmentPerUser       : int,
        _investmentCap              : int,
        _endsAt                     : int,
        _investors                  : map(int, address),
        _investments                : map(address, int),
        _totalFundsRaised           : int,
        _payoutInProcess            : bool,
        _revenueToSplit             : int,
        _nextInvestorPayoutIndex    : int,
        revenue_mint_batch_size     : int }

    public stateful function init(
        organization: OrgInterface, 
        minInvestmentPerUser: int,
        maxInvestmentPerUSer: int,
        investmentCap: int,
        endsAt: int) : state =
        require(
            Call.caller == organization.owner(),
            "Must be organization owner to be able to create Project.")
        require(
            organization.isVerified(),
            "Organization must have an active wallet before it can create new Project.")
        { _organization = organization,
          _minInvestmentPerUser = minInvestmentPerUser,
          _maxInvestmentPerUser = maxInvestmentPerUSer,
          _investmentCap = investmentCap,
          _endsAt = endsAt,
          _investors = {},
          _investments = {},
          _totalFundsRaised = 0,
          _payoutInProcess = false,
          _revenueToSplit = 0,
          _nextInvestorPayoutIndex = 0,
          revenue_mint_batch_size = 50 }   // rethink about this constant (what value should it be? can we change it afterwards? etc..)
    
    public stateful function invest() =
        let token = state._organization.coop().token()
        let amount = token.allowance(Call.caller, Contract.address)
        let usersPreviousTotalInvestment = state._investments[Call.caller = 0]
        let usersNewTotalInvestment = usersPreviousTotalInvestment + amount
        let projectNewTotalInvestment = state._totalFundsRaised + amount
        
        require(
            state._totalFundsRaised < state._investmentCap, 
            "Can not invest, project already completely funded.")

        require(
            amount > 0,
            "Can not invest zero tokens!")
        
        require(
            usersNewTotalInvestment =< state._maxInvestmentPerUser,
            "User's investment will surpass maximum per-user investment for this project. Aborting.")

        require(
            usersNewTotalInvestment >= state._minInvestmentPerUser,
            "User's investment does not meet required minimum per-user investment for this project. Aborting.")
        
        require(
            projectNewTotalInvestment =< state._investmentCap,
            "User's investment will make total funds raised greater than project's investment cap. Aborting.")

        require(
            !hasFundingExpired(),
            "Project funding has ended.")

        token.transferFrom(Call.caller, Contract.address, amount)
        
        if (Map.member(Call.caller, state._investments))
            let newInvestorIndex = Map.size(state._investors)
            put(state{ _investors[newInvestorIndex] = Call.caller })

        put(state{
            _investments[Call.caller = 0] @ investment = investment + amount,
            _totalFundsRaised @ raised = raised + amount })

    public stateful function withdraw(tokenIssuer: address, amount: int) =
        require(
            isCompletelyFunded(),
            "Project investment cap not reached! Cannot withdraw funds.")
        
        require(
            onlyOrganizationAdmin(),
            "Only organization owner can request withdrawal of project funds.")

        state._organization.coop().token().approve(tokenIssuer, amount)
    
    public stateful function startRevenueSharesPayout(revenue: int) =
        require(
            onlyOrganizationAdmin(),
            "Only organization owner can initiate revenue shares payout.")

        require(
            isCompletelyFunded(),
            "Cannot start revenue share payout on project which is still in funding phase.")

        require(
            revenue > 0,
            "Revenue is zero. Aborting.")
        
        require(
            !state._payoutInProcess,
            "Cannot withdraw funds while revenue share payout is in process.")
        
        put(state{
            _revenueToSplit = revenue,
            _payoutInProcess = true,
            _nextInvestorPayoutIndex = 0 })
    
    public stateful function payoutRevenueShares() =
        require(
            onlyOrganizationAdmin(),
            "Only organization owner can payout revenue shares batch.")

        require(
            isCompletelyFunded(),
            "Cannot start payout revenue shares batch while project is still in funding phase.")
        
        require(
            state._payoutInProcess,
            "Must call startRevenueSharesPayout(revenue) before actual payout process is executed.")

        let numOfInvestors = Map.size(state._investors)
        
        let lastInvestorIndex = numOfInvestors - 1
        let lastBatchIndex = state._nextInvestorPayoutIndex + state.revenue_mint_batch_size - 1

        let fromIndex = state._nextInvestorPayoutIndex
        let toIndex =
            if (lastInvestorIndex < lastBatchIndex)
                lastInvestorIndex
            else
                lastBatchIndex
        
        let revenue = state._revenueToSplit

        if (toIndex == lastInvestorIndex)
            put(state{
                _payoutInProcess = false,
                _revenueToSplit = 0,
                _nextInvestorPayoutIndex = 0 })
        else
            put(state{ _nextInvestorPayoutIndex = toIndex + 1 })
        
        recursiveRevenuBatchPayout(fromIndex, toIndex, revenue)


    public function hasFundingExpired() : bool = Chain.timestamp > state._endsAt

    public function isCompletelyFunded() : bool = state._totalFundsRaised == state._investmentCap

    private function onlyOrganizationAdmin() : bool = Call.caller == state._organization.owner()

    private function require(b : bool, err : string) =
        if(!b) 
            abort(err)

    private stateful function recursiveRevenuBatchPayout(
        currentInvestorIndex: int, 
        lastInvestorIndex: int,
        revenue: int) =
        let investor = state._investors[currentInvestorIndex]
        let investment = state._investments[investor]
        let share = revenue * investment / state._totalFundsRaised

        state._organization.coop().token().transfer(investor, share)

        if (currentInvestorIndex < lastInvestorIndex)
            recursiveRevenuBatchPayout(currentInvestorIndex + 1, lastInvestorIndex, revenue)
